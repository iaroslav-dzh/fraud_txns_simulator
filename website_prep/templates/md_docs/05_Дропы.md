
# Дропы

**Генерация дропов реализована** в первую очередь через классы в отличие от легальных и compromised транзакций где основа это функции. Просто на дропах я решил попробовать применить классы и понял, что удобнее т.к. удобно контролировать состояния и передавать их.  

**Ноутбуки**: ==ссылка на все==  

## Суть генерации  

**Дропов два типа:**

- *распределители*. Переводом получают деньги и просто занимаются их распределением и перенаправлением. Т.е. либо переводят дальше, либо снимают в банкомате, либо покупают криптовалюту. 
- *покупатели*. Переводом получают деньги и совершают покупки в интернете. Подразумевается что они собираются продавать купленное для отмывания денег.  

**У каждого дропа есть "жизненный цикл"**: от первой транзакции до блокировки.  
Активность дропа реализована следующим способом:

1. начало "жизни" первая входящая транзакция, первая партия денег
2. дроп распределяет/тратит эти деньги
3. когда потратил то снова входящая транзакция
4. снова распределение/трата полученной партии денег
5. во время всего жизненного цикла ведется подсчет входящих исходящих транзакций
6. перед любой транзакцией происходит проверка должна ли она быть отклонена. Транзакция отклоняется если какой-то их лимитов достигнут - вх./исх. Лимиты выставляются в `drops.yaml` файле
7. Если отклонена исходящая транзакция, то происходит генерация случайного числа попыток. Сколько попыток, столько раз дроп попытается еще совершить операцию. Если попыток 0, то дроп не пытается после первой отклоненной транзакции. Если например 3, то будет пробовать 3 раза.
8. Когда дроп больше не пытается или вообще не пытается совершать операции, то происходит попытка перевода дропу денег и она отклоняется. На этом "жизненный цикл" дропа заканчивается, ему больше не пытаются перевести деньги и сам он заблокирован
9. После этого переходим к созданию следующего дропа и так далее.  

**Подразумеваются сценарии** того как дроп работает с полученными деньгами.  
У распределителей их четыре:

1. полученные деньги переводятся дальше по частям - возможны покупки криптовалюты
2. полученные деньги переводятся дальше одним переводом - или покупается криптовалюта на все
3. полученные деньги снимаются целиком
4. полученные деньги частично снимаются, а остальное переводится дальше по частям - возможны покупки криптовалюты  

У покупателей их два:

1. покупка на все деньги
2. разбивка денег на несколько покупок

## Конфиги и данные для генерации  

Также как и в легальных транзакциях и у compromised фрода у дропов есть свои конфиги и данные в которых они нуждаются для генерации. Все это точно также упаковывается в конфиг класс и передается в функции и классы относящиеся к дропам. Для каждого типа дропа создается свой конфиг класс т.к. есть различия в конфигурациях и потому что генерация транзакций для обоих типов происходит по отдельности.

- конфиг классы `DropDistributorCfg` и `DropPurchaserCfg`
- конструктор конфиг классов `DropConfigBuilder`

## Базовые классы  

**Основа генерации дропов**. В них входят:

1. `DropAccountHandler` класс управления счетами транзакций дропов
2. `DropAmountHandler` класс генерации сумм транзакций, контроль баланса дропа
3. `DropTimeHandler` класс управления и генерации времени дропа
4. `DistBehaviorHandler` и `PurchBehaviorHandler` классы управления поведением дропов, у каждого типа дропа свой класс: 
	- общие элементы функционала для обоих классов: выбор сценария работы с деньгами, генерация попыток операций после блокировки, вычитание попыток, контроль прекращения попыток, 
	- элементы только для дропов распределителей: случайное решение будет ли транз-ция покупкой криптовалюты; случайное решение будет ли перевод переводом другому дропу внутри банка
5. `DropTxnPartData` класс генерации частичных данных транзакции: мерчант id, координаты, IP-адрес, город, id устройства, канал, тип транзакции  

**Как устроена генерация времени дропов**

1. начало "жизни" дропа, входящая транзакция, время берется случайное из диапазона таймстемпов, которые в конфиг классе
2. Время дропа генерируется по периодам активности. Период это когда дроп совершает операции через небольшие промежутки времени до нескольких часов, например от получаса до трех часов - промежутки определяются в в конфигах `drops.yaml` 
3. также в конфигах `drops.yaml` выставляются лимиты на активность в периоде, если лимит на вх. или исх. транзакции достигнут, то дроп уходит на паузу, которая рассчитывается так: **время первой транзакции в текущем периоде активности** + **случайная положительная разница** (подразумевается что это несколько часов, например 24 часа) + **случайная либо положительная либо отрицательная небольшая разница** = **время начала нового периода**. Последняя разница нужна чтобы время начала нового периода не совпадало точь-в-точь с временем начала нового периода  


## Генерация транзакций  

Реализована через один класс - `CreateDropTxn`, который использует все базовые классы.
Класс непосредственно генерирует любые транзакции: входящий перевод, исходящий, снятие, покупка криптовалюты, покупка товаров в интернете. Он приспособлен для использования для обоих типов дропов.  
Также этот класс считает количество входящих и исходящих транзакций и определяет достигнут ли какой-то из лимитов  


## Обработка партии полученных денег  

Реализована через отдельный класс - `DropBatchHandler`. В этом классе два отдельных метода под каждый тип дропа. **Но они имеют в целом общую логику:**

1. Подразумевается что баланс дропа больше 0 на момент вызова метода. Баланс пополняется через генерацию входящей транзакции вне метода. О балансе метод узнает через класс управления балансом и суммами транз-ций
2. Пока баланс больше 0 дроп совершает операции или одну операцию, зависит от того какой сценарий выпал - сценарий выбирается вне метода и передается через класс управления поведением дропа
3. Перед каждой операцией происходит проверка на то, будет ли она отклонена
4. Если не было отклонения транзакции и баланс обнулен, то партия денег обработана
5. Если баланс не 0 и транзакция отклоняется, то баланс не изменяется
6. После первой отклоненной транзакции определяется случайное число попыток совершить операцию
7. Если не выпало 0 попыток, то дроп пробует совершить операцию пока попытки не равны 0. Когда они равны 0, то обработка партии закончена  

**Отличия**  
Метод `distributor()` дропы распределители:

- есть случайный выбор между переводом/снятием и покупкой криптовалюты
- если выпал перевод, то есть случайный выбор отправлять ли деньги другому дропу внутри банка  

Метод `purchaser()` дропы покупатели:

- не имеет своих собственных особенностей, в нем то, что указано в общей логике

## Управление жизненным циклом дропа  

Реализовано через отдельный класс `DropLifecycleManager`.  

**Основная логика**

1. получаем счет текущего клиента
2. помечаем текущего клиента как дропа в таблице `accounts`, которая находится в атрибуте `DropAccountHandler.accounts`
3. переводим дропу деньги - создаем вх. транз-цию и добавляем в список транзакций текущего дропа. **Перед этим проверяем** будет ли входящая транзакция отклонена, но при первой транзакции такого не бывает.
4. Если транзакция отклонена, то генерация прерывается. Но для первой транзакции это не актуально.
5. случайно выбираем сценарий, как дроп будет распределять полученные деньги
6. в соответствии с выбранным сценарием определяем будут ли полученные деньги распределены на части или будет одна операция
7. запускаем метод обработки батча полученных денег `DropBatchHandler.process_batch()`, который обрабатывает полученный батч в соответствии с типом дропа
8. сгенерированные при обработке батча транзакции добавляем в список транзакций текущего дропа
9. снова возвращаемся к **п.3** - перевод новой партии денег дропу. Если при обработке предыдущего батча был достигнут абсолютный лимит транз-ций дропа, то входящая транзакция будет отклонена и жизненный цикл дропа закончится, будто после первой отклоненной входящей транзакции дропу больше не пытаются послать деньги
10. если транзакция не отклонена, то снова запускается `DropBatchHandler.process_batch()` и так далее

## Генерация активности множества дропов  

Реализована через один класс - `DropSimulator`.  
Фактически этот класс осуществляет полную генерацию активности дропов выбранного типа, включая запись результатов в файл.  

**Основная логика**

1. проход циклом через клиентов семплированных под определенный тип дроп фрода
2. на каждой итерации симуляция полного жизненного цикла текущего дропа
3. запись созданных транзакций дропа в общий список всех транзакций дропов данного типа
4. в конце запись измененного датафрейма `accounts` в файл в двух директориях. Запись нужна, чтобы при генерации другого типа дропов можно было узнать изменения т.к. там помечается кто из клиентов дроп; и, возможно для выгрузки актуальной таблицы в БД
5. запись сгенерированных транзакций в файл в две директории: созданную под текущий запуск генератора транзакций и директорию последнего запуска генератора - делается при помощи класса записи фрод транзакций - `FraudTxnsRecorder`


## Оркестрация генерации

**Для дропов** есть отдельный класс оркестратор - `DropsRunner`, который получает на вход данные конфиг файлов, путь к директории текущего запуска и тип дропов. Исходя из этих данных он создает объект конфиг билдера.  
При вызове метода `run()`  через конфиг билдер создается объект конфиг класса для указанного типа дропов и объекты других нужных классов. И происходит полный процесс генерации транзакций дропов указанного типа.

